* I want to separate common functionality into separate classes, things like getTileBy#particular method#, also all the events ariving from the server, they should all be in one place. I want all these separate classes to "extends" my main game class but i dont know how to do it without that weir error about prototype and can not be undefined.

* Is there a better way to manage tile explosion hitting a player so that it doesnt have to involve gameService, what is the defined purpose/role of gameService



movement
while arrow is held down move action will continue to fire ever half sec
when key is released move event will stop firing

player can press and release to quickly restart the move interval so that there is no interval
- to stop the payer from doing this, every time a move order is issues a timer goes on that the player cant issue another move command for another half a seccond


?when should the other players get an update?
when a tree is removed
when a tree explodes - send items dropped
when player moves
when player changes facing direction
when a player throws a bomb
when items are picked up
when a player dies
when a tree is siphoned
when a player goes invisible
when a player uses an ability


?what does the game do?
moves the board to center on the player
spawns trees

?what does a tile do?
renders game board entity
animates game board entity

?what does a bomb do?
travel in one direction
explode


?what can a tentacle do?
grab an enemy
can spawn
can despawn





import { HostListener } from '@angular/core'
import { PlayerDefinition, GameBoardEntity } from '../../definitions/interface-definitions'
import { Direction, Explosion, FailOrSucceed, Ability, TreeAcid, PlayerStats, PlayerStatsItem, Bomb, EssenceColour, BombItem, Loot } from '../../definitions/class-definitions'
import { Tile } from '../../the-game/tile/tile.component'
import { ConnectionService } from '../../connection-service/connection-service'
import { TheGame } from '../the-game.component'
import { Abilities } from './abilities'




export class Player implements PlayerDefinition, GameBoardEntity{
    playerNumber: number;
    abilities: Abilities;
    facing: Direction = Direction.down;
    playerTile: Tile;
    stats: PlayerStats = new PlayerStats();
    startLocation: Tile;
    playerIsOut: Boolean;
    ableToMove: Boolean = true;
    moveCycle;


    constructor(private theGame: TheGame){
        this.playerNumber = this.theGame.serverGameObject.yourPlayerNumber;
        this.abilities = new Abilities(this, this.theGame)
    }
    
    
    move(direction: Direction): FailOrSucceed{

        if(direction in Direction && this.ableToMove){
            console.log('direction '+Direction[direction]+' ableToMove '+this.ableToMove)
            if(this.facing !== direction){
                clearTimeout(this.moveCycle)
            }

            if(!this.moveCycle){
                let moveSuccess = this.move(direction)
                this.ableToMove = false;
                
                this.moveCycle = setTimeout(() => {
                    console.log('moveCycle')
                    this.moveCycle = undefined
                }, 400);

                if(!moveSuccess){
                    this.ableToMove = true;
                }
            }
        }


        this.setFacingDirection(direction)
        let result: FailOrSucceed = this.playerService.move(direction, this);
        if(result.FailOrSucceed){
            this.theGame.broadcastEventToOtherPlayers('player move update', { playerNumber: this.playerNumber, direction: direction })
        }
        return result;
    }

    breakMoveCycle(){
        clearTimeout(this.moveCycle);
        this.moveCycle = undefined;
    }
    
    hitByExplosion(explosion: Explosion){
        this.playerService.hitByExplosion(explosion, this)
    };

    hitByTreeAcid(explosion: TreeAcid){
        this.playerService.hitByTreeAcid(explosion, this)
    };

    setFacingDirection(direction: Direction){
        this.playerService.setFacingDirection(direction, this)
        this.playerService.broadcastEventToOtherPlayers('player facingDirection update', { playerNumber: this.playerNumber, direction: direction })
        
    }

    playerHealthChange(health: number){
        this.playerService.playerHealthChange(health, this)
    }

    playerDies(){
        this.playerService.playerDies(this)
    }

    pickUpLoot(loot: Loot){
        this.playerService.pickUpLoot(loot, this)
    }

    moveToStartLocation(){
        this.playerService.moveToStartLocation(this);
    }

    enterTile(tile: Tile){}
    leaveTile(tile: Tile){}

    
    useAbility(ability: Ability): FailOrSucceed{
        if(ability === Ability['Siphon Tree']){
            this.siphonTree()
        }
        if(ability === Ability['Throw Bomb']){
            if(this.stats.bombs >= 1){
                this.throwBomb()
                this.stats.bombs--
                this.theGame.gameHud.updateStats(HudItem.bombs, this.stats.bombs)
            }
        }
        

        return <FailOrSucceed>{ FailOrSucceed: true }
    };
    throwBomb(player: Player): FailOrSucceed{
        console.log('throwing bomb')
        let bomb: Bomb = new Bomb(player.facing, player.stats.bombExplosionSize, player.stats.bombThrowRange, player)
        player.playerTile.bombEnterTile(bomb)
        this.gameService.bombTravel(bomb, player.playerTile)

        if(player.playerNumber === this.gameService.user.player.playerNumber){
            this.connectionService.sendPacket({
                eventName: 'player throwBomb update',
                data: { playerNumber: player.playerNumber }
            })
        }

        return <FailOrSucceed>{ FailOrSucceed: true }
    };

    pickUpLoot(loot: Loot, player: Player){
        if(loot.bombs){
            player.stats.bombs += loot.bombs
            this.gameService.updateHud(player, HudItem.bombs, player.stats.bombs)
        }
        if(loot.essenceColour === EssenceColour.blue){
            player.stats.blueEssence++
            this.gameService.updateHud(player, HudItem.blueEssence, player.stats.blueEssence)
        }
        if(loot.essenceColour === EssenceColour.green){
            player.stats.greenEssence++
            this.gameService.updateHud(player, HudItem.greenEssence, player.stats.greenEssence)
        }
        if(loot.essenceColour === EssenceColour.yellow){
            player.stats.yellowEssence++
            this.gameService.updateHud(player, HudItem.yellowEssence, player.stats.yellowEssence)
        }
        if(loot.essenceColour === EssenceColour.purple){
            player.stats.purpleEssence++
            this.gameService.updateHud(player, HudItem.purpleEssence, player.stats.purpleEssence)
        }
    }

    moveToStartLocation(player: Player){
        player.facing = Direction.down;
        player.playerTile = player.startLocation
        this.moveIntoTile(player);
        let surroundingTiles = this.gameService.getTilesWithXRadius(1, player.startLocation)
        surroundingTiles.forEach(tile => tile.treeLeaveTile());
    }

        
    playerHealthChange(health: number, player: Player){
        player.stats.health += health
        this.gameService.updateHud(player, HudItem.health, player.stats.health)
        if(player.stats.health <= 0) player.playerDies()
    }

    playerDies(player: Player){
        player.playerTile.playerRemovedFromTile(player)
        player.stats.lives--
        this.gameService.updateHud(player, HudItem.lives, player.stats.lives)
        if(player.stats.lives <= 0 ){
            console.log('Game Over!');
            player.playerIsOut = true;
        }else {
            player.stats.health = player.stats.maxHealth
            player.stats.bombs = player.stats.maximumBombs
            this.gameService.updateHud(player, HudItem.health, player.stats.health)
            player.moveToStartLocation();
        }
    }
    
    hitByExplosion(explosion: Explosion, player: Player){
        player.playerHealthChange(-explosion.damage)
    };
    hitByTreeAcid(explosion: TreeAcid, player: Player){
        player.playerHealthChange(-explosion.damage)
    };
    setFacingDirection(direction: Direction, player: Player){
        player.facing = direction;
        player.playerTile.tileComponent.setPlayerFacingDirection(direction);
    }
    

    moveIntoTile(player: Player){
        player.playerTile.playerEnterTile(player);
        if(player.playerNumber === this.gameService.user.player.playerNumber){
            this.gameService.moveBoard(player.playerTile);
        }
    }

    move(direction:Direction, player: Player): FailOrSucceed{

        let playerTile = player.playerTile
        let destinationTile: Tile = this.gameService.getDestinationTile(playerTile, direction)

        let movingOut = playerTile.playerMovingOutOfTile(direction)
        let movingIn = destinationTile.playerMovingInToTile(direction)

        if(movingOut && movingIn){
            
            playerTile.playerLeaveTile(player);

            let movingIntoTile = setTimeout(() => {
                console.log('player move')
                player.playerTile = destinationTile;
                this.moveIntoTile(player)
                player.ableToMove = true;
            }, 400)

            return <FailOrSucceed>{ FailOrSucceed: true }
        }

        return <FailOrSucceed>{ FailOrSucceed: false, reason: 'invalid move' }
        
    };


    




    /************************** Server Events *************************************************************/

  
    manageEventsFromServer(serverEvent: Packet){
        let eventsObject = {
            "bomb and essence tile update": serverEvent => this.updateEssenceAndBombsInTile(serverEvent),
            "player move update": serverEvent => this.playerMoveEvent(serverEvent),
            "player location change": serverEvent => this.updatePlayersLocation(serverEvent),
            "player throwBomb update": serverEvent => this.throwBombEvent(serverEvent),
            "player facingDirection update": serverEvent => this.setFacingDirectionUpdate(serverEvent),
            "itemDrop update": serverEvent => this.itemDropUpdate(serverEvent),
            "treeExplode update": serverEvent => this.treeExplodeUpdate(serverEvent),
            "player moveToStartLocation update": serverEvent => this.moveToStartLocationUpdate(serverEvent),
        }
        if(eventsObject[serverEvent.eventName]){
            eventsObject[serverEvent.eventName](serverEvent.data)
        }
    }

    moveToStartLocationUpdate(data){
        console.log('server moveToStartLocation update')
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber);
        this.moveToStartLocation(player);
    }

    treeExplodeUpdate(data){
        console.log('server tree explode update')
        let tile = this.gameService.getTileById(data.tileId)
        tile.treeExplode();
    }

    itemDropUpdate(data){
        console.log('server item drop update')
        let tile = this.gameService.getTileById(data.tileId)
        tile.treeLeaveTile();
        tile.itemDrop(data.bombs, data.essenceObj)
    }

    
    throwBombEvent(data){
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber);
        this.throwBomb(player)
    }

    setFacingDirectionUpdate(data){
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber);
        this.setFacingDirection(data.direction, player)
    }

    playerMoveEvent(data){
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber);
        let direction: Direction = data.direction
        this.move(direction, player)
    }

    playerUseAbilityEvent(data){
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber);
        let ability: Ability = data.ability
        this.useAbility(ability, player)
    }

    updateEssenceAndBombsInTile(data){
        let leavingTile = this.gameService.getTileById(data.leavingTileId)
        let enteringTile = this.gameService.getTileById(data.enteringTileId)
        let player = this.gameService.getPlayerByPlayerNumber(data.playerNumber)
        if(leavingTile){
            leavingTile.playerLeaveTile(player)
        }
        data.targetTile.essenceEnterTile(...data.essenceEnterTileData);
        data.targetTile.bombEnterTile(data.bombs);
    }

    

    updatePlayersLocation(data){
        let leavingTile: Tile = this.gameService.getTileById(data.leavingTileId)
        let enteringTile: Tile = this.gameService.getTileById(data.enteringTileId)
        let player: Player = this.gameService.getPlayerByPlayerNumber(data.playerNumber)
        leavingTile.tileComponent.setPlayerFacingDirection(data.facing);
        enteringTile.tileComponent.setPlayerFacingDirection(data.facing);
        player.facing = data.facing;


        if(player.playerNumber !== this.gameService.user.player.playerNumber){
            
            leavingTile.playerLeaveTile(player)
            setTimeout(() => {
                enteringTile.playerEnterTile(player)
                
            }, 400)

        }
    }

}